% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gibbs-sampler.R
\name{gibbs_sampler}
\alias{gibbs_sampler}
\title{Gibbs sampler for model based classification.}
\usage{
gibbs_sampler(
  z0,
  y,
  V,
  mu,
  Sigma,
  rho,
  v_k,
  omega,
  N,
  q,
  K,
  iter = 1500,
  burn = 500,
  returnOpt = FALSE,
  reord = FALSE,
  true_mu = NULL
)
}
\arguments{
\item{z0}{Initial estimate of the cluster membership indicator vector of length `N`.}

\item{y}{Observed data of dimension `N x q`.}

\item{V}{Observed Fisher information array of dimension `q x q x N`.}

\item{mu}{Cluster means matrix of dimension `K x q`.}

\item{Sigma}{Cluster variance array of dimension `q x q x K`.}

\item{rho}{Gaussian Mixture model weight of vector of length `K`.}

\item{v_k}{Baseline degree of freedom for Sigma. Either a vector of length `K` or a scalar.}

\item{omega}{Baseline scale matrix for Sigma. Either a `q x q` matrix or a `q x q x K` array.}

\item{N}{Number of observations (positive integer).}

\item{q}{Size of \eqn{\theta_i} (positive integer).}

\item{K}{Number of clusters (positive integer).}

\item{iter}{Number of Gibbs sampling iterations, default to 1500.}

\item{burn}{Number of warm-up iterations, default to 500.}

\item{returnOpt}{Boolean for whether \eqn{\Theta} and \eqn{z} should be returned.}

\item{reord}{Boolean for whether the original order of clusters is recovered. Please see `relabel()`.}

\item{true_mu}{Ground truth means matrix of dimension `K x q`, if known, for reordering. Please see `relabel()`.}
}
\value{
A list consisting of:
\eqn{\rho} (a `K x (iter-burn)` matrix),
\eqn{\mu} (a `K x q x (iter-burn)` array),
\eqn{\Sigma} (a `q x q x K x (iter-burn)` array),
\eqn{\Lambda} (a `N x K` matrix),
\eqn{\Theta} (a `N x q x (iter-burn)` array, optional), and
\eqn{z} (a `N x (iter-burn)` matrix, optional).
}
\description{
Gibbs sampler for model based classification.
}
\examples{
# This is a simulated example
N <- 100
q <- 5
K <- 4
true_z <- sample(1:K, N, TRUE)
true_mu <- matrix(rnorm(q*K, 0, 5), ncol = q)
true_Sigma <- replicate(K, expr = {mniw::rwish(1, diag(q)*runif(1, 0.01, 0.1), q+1)})
true_Theta <- mniw::rmNorm(N, true_mu[true_z,], true_Sigma[,,true_z])
V <- replicate(N, expr = {mniw::rwish(1, diag(q)*0.05, q+1)})
y <- mniw::rmNorm(N, true_Theta, V)
v_k <- q + 2
Var_y <- cov(y)
params <- init_params(y, K, type = "kmeans")
# usually, for the Gibbs sampler to converge, more iterations are needed
gs <- gibbs_sampler(params$z0, params$Theta, V, params$mu, params$Sigma,
                        params$rho, v_k, Var_y, N, q, K, iter=50, burn=10)

}
